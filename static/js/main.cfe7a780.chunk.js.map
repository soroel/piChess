{"version":3,"sources":["Chess/PromotionDialog.tsx","Chess/CheckmatePopup.tsx","Chess/ChessBoard.tsx","Chess/MoveHistory.tsx","Chess/GameModeSelector.tsx","Chess/CapturedPieces.tsx","Chess/ComputerPlayer.ts","Chess/Chess.tsx","PiWrapper.tsx","index.tsx"],"names":["PIECE_SYMBOLS","queen","white","black","rook","bishop","knight","PIECE_DESCRIPTIONS","PromotionDialog","_ref","color","position","onSelect","useEffect","handleKeyDown","e","key","window","addEventListener","removeEventListener","_jsx","className","children","_jsxs","style","left","concat","x","top","y","transform","animation","role","map","pieceType","onClick","title","toUpperCase","CheckmatePopup","winner","onNewGame","charAt","slice","king","pawn","FILES","RANKS","ChessBoard","currentPlayer","gameStatus","onMove","boardHistory","initializeBoard","useCallback","newBoard","i","row","j","push","piece","getInitialPiece","board","setBoard","useState","selectedPiece","setSelectedPiece","validMoves","setValidMoves","boardState","setBoardState","lastMove","canEnPassant","promotionState","setPromotionState","setLastMove","boardRef","useRef","col","type","getSquareNotation","parseSquareNotation","notation","file","toLowerCase","parseInt","indexOf","isValidCastling","kingPos","rookPos","_boardState$lastMove","direction","testBoard","square","_objectSpread","isKingInCheck","getPieceMoves","pos","moves","startRow","newRow","twoSquares","forEach","offset","newCol","targetPiece","_ref2","rowOffset","colOffset","_ref3","rowDir","colDir","_ref4","_ref5","_ref6","findKingPosition","isSquareUnderAttack","byColor","pawnDirection","pawnAttacks","attack","knightMoves","diagonalDirections","straightDirections","kingMoves","canBlockCheck","checkingPieces","opponentColor","directions","isDiagonal","Math","abs","getCheckingPieces","length","canKingEscape","checkingPiece","checkingPieceType","canCaptureCheckingPiece","from","to","squares","sign","getSquaresBetween","some","canSquareBeCovered","move","boardCopy","checkingPiecePos","isCheckmate","handleSquareClick","movingPiece","isCapture","rookCol","newRookCol","newBoardState","current","querySelector","rect","getBoundingClientRect","boardRect","width","height","dialogPosition","handlePawnPromotion","isCheck","wouldBeCheckmate","capture","check","checkmate","isCheckTest","arguments","undefined","enPassantRow","_boardState$canEnPass","filter","getValidMoves","lastState","fromCoords","toCoords","ref","_square$piece","isLastMoveFrom","isLastMoveTo","MoveHistory","formatMove","_Fragment","index","floor","GameModeSelector","onSelectMode","username","CapturedPieces","pieces","getPieceSymbol","pieceValues","sortedPieces","sort","a","b","PIECE_VALUES","POSITION_VALUES","ComputerPlayer","isSlidingPiece","includes","this","isValidPosition","targetSquare","evaluatePosition","score","value","minimax","depth","alpha","beta","isMaximizing","bestMove","maxScore","Infinity","makeMove","evaluation","max","minScore","min","getBestMove","Chess","setCurrentPlayer","setGameStatus","moveHistory","setMoveHistory","setBoardHistory","canUndo","setCanUndo","gameMode","setGameMode","computerPlayer","capturedPieces","setCapturedPieces","handleMove","prevMoves","prevPlayer","newStatus","capturedPiece","capturingColor","prev","prevHistory","timeoutId","setTimeout","computerMove","_lastState$board$comp","clearTimeout","charCodeAt","handleNewGame","handleUndo","newMoveHistory","pop","newBoardHistory","previousState","disabled","PiWrapper","setUsername","isAuthenticated","setIsAuthenticated","error","setError","isLoading","setIsLoading","onIncompletePayment","payment","console","log","Pi","init","version","sandbox","timer","async","Error","result","authenticate","onIncompletePaymentFound","user","err","message","ReactDOM","render","React","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.cfe7a780.chunk.js","sourcesContent":["import React, { useEffect } from 'react';\nimport './PromotionDialog.css';\nimport { PieceColor } from './Chess';\n\ninterface PromotionDialogProps {\n  color: PieceColor;\n  position: { x: number; y: number };\n  onSelect: (pieceType: 'queen' | 'rook' | 'bishop' | 'knight') => void;\n}\n\nconst PIECE_SYMBOLS = {\n  queen: { white: '♕', black: '♛' },\n  rook: { white: '♖', black: '♜' },\n  bishop: { white: '♗', black: '♝' },\n  knight: { white: '♘', black: '♞' }\n};\n\nconst PIECE_DESCRIPTIONS = {\n  queen: 'Moves any number of squares diagonally, horizontally, or vertically',\n  rook: 'Moves any number of squares horizontally or vertically',\n  bishop: 'Moves any number of squares diagonally',\n  knight: 'Moves in an L-shape: 2 squares in one direction and 1 square perpendicular'\n};\n\nconst PromotionDialog: React.FC<PromotionDialogProps> = ({ color, position, onSelect }) => {\n  const promotionPieces: Array<'queen' | 'rook' | 'bishop' | 'knight'> = [\n    'queen', 'rook', 'bishop', 'knight'\n  ];\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        onSelect('queen'); // Default to queen on ESC (or add a cancel option)\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [onSelect]);\n\n  return (\n    <div className=\"promotion-overlay\">\n      <div \n        className=\"promotion-dialog\"\n        style={{\n          position: 'absolute',\n          left: `${position.x}px`,\n          top: `${position.y}px`,\n          transform: 'translate(-50%, -50%)',\n          animation: 'slideIn 0.3s ease-out'\n        }}\n        role=\"dialog\"\n        aria-modal=\"true\"\n        aria-label=\"Pawn promotion selection\"\n      >\n        <div className=\"promotion-header\">\n          Choose a piece for promotion\n        </div>\n        <div className=\"promotion-options\">\n          {promotionPieces.map(pieceType => (\n            <button\n              key={pieceType}\n              className=\"promotion-option\"\n              onClick={() => onSelect(pieceType)}\n              title={PIECE_DESCRIPTIONS[pieceType]}\n              aria-label={`Promote to ${pieceType}`}\n            >\n              <div className=\"piece-symbol\">\n                {PIECE_SYMBOLS[pieceType][color]}\n              </div>\n              <div className=\"piece-name\">\n                {pieceType.toUpperCase()}\n              </div>\n            </button>\n          ))}\n        </div>\n        <div className=\"promotion-footer\">\n          Press ESC to cancel (default: Queen)\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PromotionDialog;\n","import React from 'react';\nimport './CheckmatePopup.css';\nimport { PieceColor } from './Chess';\n\ninterface CheckmatePopupProps {\n  winner: PieceColor;\n  onNewGame: () => void;\n}\n\nconst CheckmatePopup: React.FC<CheckmatePopupProps> = ({ winner, onNewGame }) => {\n  return (\n    <div className=\"checkmate-overlay\">\n      <div className=\"checkmate-popup\">\n        <div className=\"checkmate-content\">\n          <h2>Checkmate!</h2>\n          <p>{winner.charAt(0).toUpperCase() + winner.slice(1)} wins!</p>\n          <button className=\"new-game-button\" onClick={onNewGame}>\n            New Game\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default CheckmatePopup; ","import React, { useState, useRef, useEffect, useCallback } from 'react';\nimport './ChessBoard.css';\nimport { PieceColor, GameStatus } from './Chess';\nimport PromotionDialog from './PromotionDialog';\nimport CheckmatePopup from './CheckmatePopup';\n\ntype PieceType = 'king' | 'queen' | 'rook' | 'bishop' | 'knight' | 'pawn';\n\ninterface Piece {\n  type: PieceType;\n  color: PieceColor;\n}\n\ninterface Square {\n  piece: Piece | null;\n  color: PieceColor;\n}\n\ninterface Position {\n  row: number;\n  col: number;\n}\n\ninterface Move {\n  piece: string;\n  from: string;\n  to: string;\n  capture?: boolean;\n  check?: boolean;\n  checkmate?: boolean;\n}\n\ninterface ChessBoardProps {\n  currentPlayer: PieceColor;\n  gameStatus: GameStatus;\n  onMove: (move: Move, boardState: Square[][]) => void;\n  onNewGame: () => void;\n  boardHistory: Array<{\n    board: Array<Array<{\n      piece: { type: string; color: PieceColor } | null;\n      color: PieceColor;\n    }>>;\n    currentPlayer: PieceColor;\n    gameStatus: GameStatus;\n    move: Move;\n  }>;\n}\n\ninterface ChessBoardState {\n  lastMove: {\n    piece: Piece;\n    from: Position;\n    to: Position;\n  } | null;\n  canEnPassant: Position | null;\n}\n\ninterface PromotionState {\n  position: Position;\n  dialogPosition: { x: number; y: number };\n}\n\nexport interface PromotionDialogProps {\n  color: PieceColor;\n  position: { x: number; y: number };\n  onSelect: (type: 'queen' | 'rook' | 'bishop' | 'knight') => void;\n}\n\nconst PIECE_SYMBOLS: { [key in PieceType]: { [key in PieceColor]: string } } = {\n  king: { white: '♔', black: '♚' },\n  queen: { white: '♕', black: '♛' },\n  rook: { white: '♖', black: '♜' },\n  bishop: { white: '♗', black: '♝' },\n  knight: { white: '♘', black: '♞' },\n  pawn: { white: '♙', black: '♟' }\n};\n\nconst FILES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nconst RANKS = ['8', '7', '6', '5', '4', '3', '2', '1'];\n\nconst ChessBoard: React.FC<ChessBoardProps> = ({ \n  currentPlayer, \n  gameStatus, \n  onMove, \n  onNewGame,\n  boardHistory \n}) => {\n  // Initialize the board function using useCallback\n  const initializeBoard = useCallback((): Square[][] => {\n    const newBoard: Square[][] = [];\n    for (let i = 0; i < 8; i++) {\n      const row: Square[] = [];\n      for (let j = 0; j < 8; j++) {\n        row.push({\n          piece: getInitialPiece(i, j),\n          color: (i + j) % 2 === 0 ? 'white' : 'black'\n        });\n      }\n      newBoard.push(row);\n    }\n    return newBoard;\n  }, []); // No dependencies needed as it's a pure function\n\n  const [board, setBoard] = useState<Square[][]>(initializeBoard());\n  const [selectedPiece, setSelectedPiece] = useState<Position | null>(null);\n  const [validMoves, setValidMoves] = useState<Position[]>([]);\n  const [boardState, setBoardState] = useState<ChessBoardState>({\n    lastMove: null,\n    canEnPassant: null\n  });\n  const [promotionState, setPromotionState] = useState<PromotionState | null>(null);\n  const [lastMove, setLastMove] = useState<{ from: Position; to: Position } | null>(null);\n  const boardRef = useRef<HTMLDivElement>(null);\n\n  // Update board when history changes\n  useEffect(() => {\n    if (boardHistory.length > 0) {\n      const lastState = boardHistory[boardHistory.length - 1];\n      setBoard(lastState.board as Square[][]);\n      if (lastState.move) {\n        const fromCoords = parseSquareNotation(lastState.move.from);\n        const toCoords = parseSquareNotation(lastState.move.to);\n        setLastMove({ from: fromCoords, to: toCoords });\n      }\n    } else {\n      setBoard(initializeBoard());\n      setLastMove(null);\n    }\n  }, [boardHistory, initializeBoard]);\n\n  function getInitialPiece(row: number, col: number): Piece | null {\n    if (row <= 1) {\n      const color: PieceColor = 'black';\n      if (row === 1) return { type: 'pawn', color };\n      const pieceMap: PieceType[] = [\n        'rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'\n      ];\n      return { type: pieceMap[col], color };\n    } else if (row >= 6) {\n      const color: PieceColor = 'white';\n      if (row === 6) return { type: 'pawn', color };\n      const pieceMap: PieceType[] = [\n        'rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'\n      ];\n      return { type: pieceMap[col], color };\n    }\n    return null;\n  }\n\n  function getSquareNotation(row: number, col: number): string {\n    return `${FILES[col]}${8 - row}`;\n  }\n\n  function parseSquareNotation(notation: string): Position {\n    const file = notation.charAt(0).toLowerCase();\n    const rank = parseInt(notation.charAt(1));\n    return {\n      row: 8 - rank,\n      col: FILES.indexOf(file)\n    };\n  }\n\n  function isValidCastling(kingPos: Position, rookPos: Position, color: PieceColor): boolean {\n    // Check if king or rook has moved\n    if (boardState.lastMove?.piece.type === 'king' && boardState.lastMove.piece.color === color) return false;\n    \n    const row = color === 'white' ? 7 : 0;\n    if (kingPos.row !== row || kingPos.col !== 4) return false;\n    \n    const king = board[kingPos.row][kingPos.col].piece;\n    const rook = board[rookPos.row][rookPos.col].piece;\n    \n    if (!king || !rook || king.type !== 'king' || rook.type !== 'rook') return false;\n\n    // Check if path is clear\n    const direction = rookPos.col < kingPos.col ? -1 : 1;\n    for (let col = kingPos.col + direction; col !== rookPos.col; col += direction) {\n      if (board[row][col].piece) return false;\n    }\n\n    // Check if king passes through check\n    for (let col = kingPos.col; col !== kingPos.col + (direction * 3); col += direction) {\n      const testBoard = board.map(row => row.map(square => ({ ...square })));\n      testBoard[row][col].piece = king;\n      testBoard[row][kingPos.col].piece = null;\n      if (isKingInCheck(color, testBoard)) return false;\n    }\n\n    return true;\n  }\n\n  function getPieceMoves(pos: Position, piece: Piece, testBoard: Square[][]): Position[] {\n    const moves: Position[] = [];\n\n    switch (piece.type) {\n      case 'pawn':\n        const direction = piece.color === 'white' ? -1 : 1;\n        const startRow = piece.color === 'white' ? 6 : 1;\n        \n        // Forward move\n        let newRow = pos.row + direction;\n        if (newRow >= 0 && newRow < 8 && !testBoard[newRow][pos.col].piece) {\n          moves.push({ row: newRow, col: pos.col });\n          \n          // Initial two-square move\n          if (pos.row === startRow) {\n            const twoSquares = pos.row + (direction * 2);\n            if (!testBoard[twoSquares][pos.col].piece) {\n              moves.push({ row: twoSquares, col: pos.col });\n            }\n          }\n        }\n        \n        // Captures (including en passant)\n        [-1, 1].forEach(offset => {\n          const newCol = pos.col + offset;\n          if (newCol >= 0 && newCol < 8 && newRow >= 0 && newRow < 8) {\n            const targetPiece = testBoard[newRow][newCol].piece;\n            if (targetPiece && targetPiece.color !== piece.color) {\n              moves.push({ row: newRow, col: newCol });\n            }\n          }\n        });\n        break;\n\n      case 'knight':\n        const knightMoves = [\n          [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n          [1, -2], [1, 2], [2, -1], [2, 1]\n        ];\n        knightMoves.forEach(([rowOffset, colOffset]) => {\n          const newRow = pos.row + rowOffset;\n          const newCol = pos.col + colOffset;\n          if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n            const targetPiece = testBoard[newRow][newCol].piece;\n            if (!targetPiece || targetPiece.color !== piece.color) {\n              moves.push({ row: newRow, col: newCol });\n            }\n          }\n        });\n        break;\n\n      case 'bishop':\n        const bishopDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n        bishopDirections.forEach(([rowDir, colDir]) => {\n          let newRow = pos.row + rowDir;\n          let newCol = pos.col + colDir;\n          while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n            const targetPiece = testBoard[newRow][newCol].piece;\n            if (!targetPiece) {\n              moves.push({ row: newRow, col: newCol });\n            } else {\n              if (targetPiece.color !== piece.color) {\n                moves.push({ row: newRow, col: newCol });\n              }\n              break;\n            }\n            newRow += rowDir;\n            newCol += colDir;\n          }\n        });\n        break;\n\n      case 'rook':\n        const rookDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n        rookDirections.forEach(([rowDir, colDir]) => {\n          let newRow = pos.row + rowDir;\n          let newCol = pos.col + colDir;\n          while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n            const targetPiece = testBoard[newRow][newCol].piece;\n            if (!targetPiece) {\n              moves.push({ row: newRow, col: newCol });\n            } else {\n              if (targetPiece.color !== piece.color) {\n                moves.push({ row: newRow, col: newCol });\n              }\n              break;\n            }\n            newRow += rowDir;\n            newCol += colDir;\n          }\n        });\n        break;\n\n      case 'queen':\n        const queenDirections = [\n          [-1, -1], [-1, 0], [-1, 1],\n          [0, -1], [0, 1],\n          [1, -1], [1, 0], [1, 1]\n        ];\n        queenDirections.forEach(([rowDir, colDir]) => {\n          let newRow = pos.row + rowDir;\n          let newCol = pos.col + colDir;\n          while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n            const targetPiece = testBoard[newRow][newCol].piece;\n            if (!targetPiece) {\n              moves.push({ row: newRow, col: newCol });\n            } else {\n              if (targetPiece.color !== piece.color) {\n                moves.push({ row: newRow, col: newCol });\n              }\n              break;\n            }\n            newRow += rowDir;\n            newCol += colDir;\n          }\n        });\n        break;\n\n      case 'king':\n        const kingMoves = [\n          [-1, -1], [-1, 0], [-1, 1],\n          [0, -1], [0, 1],\n          [1, -1], [1, 0], [1, 1]\n        ];\n        kingMoves.forEach(([rowOffset, colOffset]) => {\n          const newRow = pos.row + rowOffset;\n          const newCol = pos.col + colOffset;\n          if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n            const targetPiece = testBoard[newRow][newCol].piece;\n            if (!targetPiece || targetPiece.color !== piece.color) {\n              moves.push({ row: newRow, col: newCol });\n            }\n          }\n        });\n        break;\n    }\n\n    return moves;\n  }\n\n  function findKingPosition(color: PieceColor, testBoard: Square[][]): Position | null {\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        const piece = testBoard[row][col].piece;\n        if (piece?.type === 'king' && piece.color === color) {\n          return { row, col };\n        }\n      }\n    }\n    return null;\n  }\n\n  function isSquareUnderAttack(pos: Position, byColor: PieceColor, testBoard: Square[][]): boolean {\n    // Check pawn attacks\n    const pawnDirection = byColor === 'white' ? 1 : -1;\n    const pawnAttacks = [\n      { row: pos.row + pawnDirection, col: pos.col - 1 },\n      { row: pos.row + pawnDirection, col: pos.col + 1 }\n    ];\n    \n    for (const attack of pawnAttacks) {\n      if (attack.row >= 0 && attack.row < 8 && attack.col >= 0 && attack.col < 8) {\n        const piece = testBoard[attack.row][attack.col].piece;\n        if (piece?.type === 'pawn' && piece.color === byColor) {\n          return true;\n        }\n      }\n    }\n\n    // Check knight attacks\n    const knightMoves = [\n      [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n      [1, -2], [1, 2], [2, -1], [2, 1]\n    ];\n    \n    for (const [rowOffset, colOffset] of knightMoves) {\n      const newRow = pos.row + rowOffset;\n      const newCol = pos.col + colOffset;\n      if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n        const piece = testBoard[newRow][newCol].piece;\n        if (piece?.type === 'knight' && piece.color === byColor) {\n          return true;\n        }\n      }\n    }\n\n    // Check diagonal attacks (bishop/queen)\n    const diagonalDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n    for (const [rowDir, colDir] of diagonalDirections) {\n      let newRow = pos.row + rowDir;\n      let newCol = pos.col + colDir;\n      while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n        const piece = testBoard[newRow][newCol].piece;\n        if (piece) {\n          if (piece.color === byColor && \n             (piece.type === 'bishop' || piece.type === 'queen')) {\n            return true;\n          }\n          break; // Stop checking this direction if we hit any piece\n        }\n        newRow += rowDir;\n        newCol += colDir;\n      }\n    }\n\n    // Check straight attacks (rook/queen)\n    const straightDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    for (const [rowDir, colDir] of straightDirections) {\n      let newRow = pos.row + rowDir;\n      let newCol = pos.col + colDir;\n      while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n        const piece = testBoard[newRow][newCol].piece;\n        if (piece) {\n          if (piece.color === byColor && \n             (piece.type === 'rook' || piece.type === 'queen')) {\n            return true;\n          }\n          break; // Stop checking this direction if we hit any piece\n        }\n        newRow += rowDir;\n        newCol += colDir;\n      }\n    }\n\n    // Check king proximity (for adjacent squares)\n    const kingMoves = [\n      [-1, -1], [-1, 0], [-1, 1],\n      [0, -1], [0, 1],\n      [1, -1], [1, 0], [1, 1]\n    ];\n    \n    for (const [rowOffset, colOffset] of kingMoves) {\n      const newRow = pos.row + rowOffset;\n      const newCol = pos.col + colOffset;\n      if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n        const piece = testBoard[newRow][newCol].piece;\n        if (piece?.type === 'king' && piece.color === byColor) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function isKingInCheck(color: PieceColor, testBoard: Square[][]): boolean {\n    const kingPos = findKingPosition(color, testBoard);\n    if (!kingPos) return false;\n\n    const opponentColor = color === 'white' ? 'black' : 'white';\n    return isSquareUnderAttack(kingPos, opponentColor, testBoard);\n  }\n\n  function getCheckingPieces(color: PieceColor, testBoard: Square[][]): Position[] {\n    const kingPos = findKingPosition(color, testBoard);\n    if (!kingPos) return [];\n\n    const checkingPieces: Position[] = [];\n    const opponentColor = color === 'white' ? 'black' : 'white';\n\n    // Check for pawns\n    const pawnDirection = opponentColor === 'white' ? 1 : -1;\n    const pawnAttacks = [\n      { row: kingPos.row + pawnDirection, col: kingPos.col - 1 },\n      { row: kingPos.row + pawnDirection, col: kingPos.col + 1 }\n    ];\n\n    for (const attack of pawnAttacks) {\n      if (attack.row >= 0 && attack.row < 8 && attack.col >= 0 && attack.col < 8) {\n        const piece = testBoard[attack.row][attack.col].piece;\n        if (piece?.type === 'pawn' && piece.color === opponentColor) {\n          checkingPieces.push({ row: attack.row, col: attack.col });\n        }\n      }\n    }\n\n    // Check for knights\n    const knightMoves = [\n      [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n      [1, -2], [1, 2], [2, -1], [2, 1]\n    ];\n    \n    for (const [rowOffset, colOffset] of knightMoves) {\n      const newRow = kingPos.row + rowOffset;\n      const newCol = kingPos.col + colOffset;\n      if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n        const piece = testBoard[newRow][newCol].piece;\n        if (piece?.type === 'knight' && piece.color === opponentColor) {\n          checkingPieces.push({ row: newRow, col: newCol });\n        }\n      }\n    }\n\n    // Check for sliding pieces (bishop, rook, queen)\n    const directions = [\n      [-1, -1], [-1, 1], [1, -1], [1, 1], // Diagonal (bishop/queen)\n      [-1, 0], [1, 0], [0, -1], [0, 1]    // Straight (rook/queen)\n    ];\n\n    for (const [rowDir, colDir] of directions) {\n      let newRow = kingPos.row + rowDir;\n      let newCol = kingPos.col + colDir;\n      while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n        const piece = testBoard[newRow][newCol].piece;\n        if (piece) {\n          if (piece.color === opponentColor) {\n            const isDiagonal = Math.abs(rowDir) === Math.abs(colDir);\n            if ((isDiagonal && (piece.type === 'bishop' || piece.type === 'queen')) ||\n                (!isDiagonal && (piece.type === 'rook' || piece.type === 'queen'))) {\n              checkingPieces.push({ row: newRow, col: newCol });\n            }\n          }\n          break; // Stop checking this direction if we hit any piece\n        }\n        newRow += rowDir;\n        newCol += colDir;\n      }\n    }\n\n    return checkingPieces;\n  }\n\n  function canBlockCheck(color: PieceColor, testBoard: Square[][]): boolean {\n    const checkingPieces = getCheckingPieces(color, testBoard);\n    if (checkingPieces.length === 0) return true;\n    \n    // If more than one piece is checking the king, the king must move\n    if (checkingPieces.length > 1) {\n      return canKingEscape(color, testBoard);\n    }\n\n    const kingPos = findKingPosition(color, testBoard)!;\n    const checkingPiece = checkingPieces[0];\n    const checkingPieceType = testBoard[checkingPiece.row][checkingPiece.col].piece!.type;\n\n    // For knight checks or adjacent pawns, we must capture the checking piece or move the king\n    if (checkingPieceType === 'knight' || checkingPieceType === 'pawn') {\n      return canCaptureCheckingPiece(color, checkingPiece, testBoard) ||\n             canKingEscape(color, testBoard);\n    }\n\n    // For sliding pieces (bishop, rook, queen), we can also block\n    const squares = getSquaresBetween(kingPos, checkingPiece);\n    return squares.some(square => canSquareBeCovered(square, color, testBoard)) ||\n           canCaptureCheckingPiece(color, checkingPiece, testBoard) ||\n           canKingEscape(color, testBoard);\n  }\n\n  function getSquaresBetween(from: Position, to: Position): Position[] {\n    const squares: Position[] = [];\n    const rowDir = Math.sign(to.row - from.row);\n    const colDir = Math.sign(to.col - from.col);\n    let row = from.row + rowDir;\n    let col = from.col + colDir;\n\n    while (row !== to.row || col !== to.col) {\n      squares.push({ row, col });\n      row += rowDir;\n      col += colDir;\n    }\n\n    return squares;\n  }\n\n  function canSquareBeCovered(pos: Position, byColor: PieceColor, testBoard: Square[][]): boolean {\n    // Check if any piece of our color can move to this square\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        const piece = testBoard[row][col].piece;\n        if (piece && piece.color === byColor) {\n          const moves = getPieceMoves({ row, col }, piece, testBoard);\n          if (moves.some(move => move.row === pos.row && move.col === pos.col)) {\n            // Verify the move doesn't leave or put the king in check\n            const boardCopy = testBoard.map(row => row.map(square => ({ ...square })));\n            boardCopy[pos.row][pos.col].piece = boardCopy[row][col].piece;\n            boardCopy[row][col].piece = null;\n            if (!isKingInCheck(byColor, boardCopy)) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  function canCaptureCheckingPiece(color: PieceColor, checkingPiecePos: Position, testBoard: Square[][]): boolean {\n    return canSquareBeCovered(checkingPiecePos, color, testBoard);\n  }\n\n  function canKingEscape(color: PieceColor, testBoard: Square[][]): boolean {\n    const kingPos = findKingPosition(color, testBoard)!;\n    const king = testBoard[kingPos.row][kingPos.col].piece!;\n    const moves = getPieceMoves(kingPos, king, testBoard);\n\n    return moves.some(move => {\n      const boardCopy = testBoard.map(row => row.map(square => ({ ...square })));\n      boardCopy[move.row][move.col].piece = king;\n      boardCopy[kingPos.row][kingPos.col].piece = null;\n      return !isSquareUnderAttack(move, color === 'white' ? 'black' : 'white', boardCopy);\n    });\n  }\n\n  function isCheckmate(color: PieceColor, testBoard: Square[][]): boolean {\n    // First, verify that the king is in check\n    if (!isKingInCheck(color, testBoard)) {\n      return false;\n    }\n\n    // Then check if any move can get out of check\n    return !canBlockCheck(color, testBoard);\n  }\n\n  function handlePawnPromotion(pos: Position): boolean {\n    const piece = board[pos.row][pos.col].piece;\n    if (!piece || piece.type !== 'pawn') return false;\n\n    // Check if pawn has reached the promotion rank\n    const isPromotionRow = (piece.color === 'white' && pos.row === 0) ||\n                          (piece.color === 'black' && pos.row === 7);\n\n    if (isPromotionRow) {\n      // Calculate dialog position\n      if (boardRef.current) {\n        const square = boardRef.current.querySelector(`[data-position=\"${pos.row}-${pos.col}\"]`);\n        if (square) {\n          const rect = square.getBoundingClientRect();\n          const boardRect = boardRef.current.getBoundingClientRect();\n          \n          // Calculate position relative to the board\n          const x = rect.left - boardRect.left + (rect.width / 2);\n          const y = rect.top - boardRect.top + (rect.height / 2);\n          \n          setPromotionState({\n            position: pos,\n            dialogPosition: { x, y }\n          });\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  function handlePromotion(pieceType: 'queen' | 'rook' | 'bishop' | 'knight') {\n    if (!promotionState || !boardState.lastMove) return;\n\n    const newBoard = board.map(row => row.map(square => ({ ...square })));\n    const piece = newBoard[promotionState.position.row][promotionState.position.col].piece!;\n    \n    // Create the promoted piece\n    newBoard[promotionState.position.row][promotionState.position.col].piece = {\n      type: pieceType,\n      color: piece.color\n    };\n\n    // Check if this promotion puts the opponent in check/checkmate\n    const opponentColor = piece.color === 'white' ? 'black' : 'white';\n    const isCheck = isKingInCheck(opponentColor, newBoard);\n    const wouldBeCheckmate = isCheck && isCheckmate(opponentColor, newBoard);\n\n    // Create move notation for the promotion\n    const move = {\n      piece: PIECE_SYMBOLS[pieceType][piece.color],\n      from: getSquareNotation(boardState.lastMove.from.row, boardState.lastMove.from.col),\n      to: getSquareNotation(promotionState.position.row, promotionState.position.col),\n      capture: boardState.lastMove.piece.type === 'pawn' && \n              boardState.lastMove.from.col !== promotionState.position.col,\n      check: isCheck,\n      checkmate: wouldBeCheckmate\n    };\n\n    setPromotionState(null);\n    onMove(move, newBoard);\n  }\n\n  function handleSquareClick(row: number, col: number) {\n    if (gameStatus === 'checkmate' || promotionState) return;\n\n    if (!selectedPiece) {\n      const piece = board[row][col].piece;\n      if (piece && piece.color === currentPlayer) {\n        setSelectedPiece({ row, col });\n        setValidMoves(getValidMoves({ row, col }, board));\n      }\n    } else {\n      const isValidMove = validMoves.some(\n        move => move.row === row && move.col === col\n      );\n\n      if (isValidMove) {\n        const newBoard = board.map(row => row.map(square => ({ ...square })));\n        const movingPiece = newBoard[selectedPiece.row][selectedPiece.col].piece!;\n        const targetPiece = newBoard[row][col].piece;\n        const isCapture = !!targetPiece || (movingPiece.type === 'pawn' && col !== selectedPiece.col);\n        \n        // Handle castling\n        if (movingPiece.type === 'king' && Math.abs(col - selectedPiece.col) === 2) {\n          const rookCol = col > selectedPiece.col ? 7 : 0;\n          const newRookCol = col > selectedPiece.col ? col - 1 : col + 1;\n          newBoard[row][newRookCol].piece = newBoard[row][rookCol].piece;\n          newBoard[row][rookCol].piece = null;\n        }\n\n        // Handle en passant capture\n        if (movingPiece.type === 'pawn' && col !== selectedPiece.col && !targetPiece) {\n          const capturedPawnRow = selectedPiece.row;\n          newBoard[capturedPawnRow][col].piece = null;\n        }\n\n        // Make the move\n        newBoard[row][col].piece = movingPiece;\n        newBoard[selectedPiece.row][selectedPiece.col].piece = null;\n\n        // Update last move\n        setLastMove({\n          from: { row: selectedPiece.row, col: selectedPiece.col },\n          to: { row, col }\n        });\n\n        // Set en passant flag\n        const newBoardState: ChessBoardState = {\n          lastMove: {\n            piece: movingPiece,\n            from: { ...selectedPiece },\n            to: { row, col }\n          },\n          canEnPassant: null\n        };\n\n        if (movingPiece.type === 'pawn' && Math.abs(row - selectedPiece.row) === 2) {\n          newBoardState.canEnPassant = { row: row, col: col };\n        }\n\n        // Update the board state immediately for visual feedback\n        setBoard(newBoard);\n        setBoardState(newBoardState);\n\n        // Check for pawn promotion\n        if (movingPiece.type === 'pawn') {\n          // Check if pawn has reached the promotion rank (first or last rank)\n          const isPromotionRank = (movingPiece.color === 'white' && row === 0) || \n                                 (movingPiece.color === 'black' && row === 7);\n          \n          if (isPromotionRank) {\n            // Show promotion dialog and wait for selection\n        const needsPromotion = handlePawnPromotion({ row, col });\n            if (needsPromotion) {\n              return; // Wait for promotion selection before completing the move\n            }\n          }\n        }\n\n        // If no promotion needed, complete the move\n          const opponentColor = currentPlayer === 'white' ? 'black' : 'white';\n          const isCheck = isKingInCheck(opponentColor, newBoard);\n          const wouldBeCheckmate = isCheck && isCheckmate(opponentColor, newBoard);\n\n          // Create move notation\n          const move = {\n            piece: PIECE_SYMBOLS[movingPiece.type][movingPiece.color],\n            from: getSquareNotation(selectedPiece.row, selectedPiece.col),\n            to: getSquareNotation(row, col),\n          capture: isCapture,\n            check: isCheck,\n            checkmate: wouldBeCheckmate\n          };\n\n          onMove(move, newBoard);\n      }\n\n      setSelectedPiece(null);\n      setValidMoves([]);\n    }\n  }\n\n  function getValidMoves(pos: Position, testBoard: Square[][], isCheckTest: boolean = false): Position[] {\n    const piece = testBoard[pos.row][pos.col].piece;\n    if (!piece || (piece.color !== currentPlayer && !isCheckTest)) return [];\n\n    // Get basic moves for the piece\n    let moves = getPieceMoves(pos, piece, testBoard);\n\n    // Add special moves if not in check test\n    if (!isCheckTest) {\n      // Add castling moves for king\n      if (piece.type === 'king' && !isKingInCheck(piece.color, testBoard)) {\n        // Kingside castling\n        if (isValidCastling(pos, { row: pos.row, col: 7 }, piece.color)) {\n          moves.push({ row: pos.row, col: pos.col + 2 });\n        }\n        // Queenside castling\n        if (isValidCastling(pos, { row: pos.row, col: 0 }, piece.color)) {\n          moves.push({ row: pos.row, col: pos.col - 2 });\n        }\n      }\n\n      // Add en passant moves for pawns\n      if (piece.type === 'pawn' && boardState.canEnPassant) {\n        const enPassantRow = piece.color === 'white' ? 3 : 4;\n        if (pos.row === enPassantRow) {\n          [-1, 1].forEach(offset => {\n            if (pos.col + offset === boardState.canEnPassant?.col) {\n              moves.push({ \n                row: pos.row + (piece.color === 'white' ? -1 : 1), \n                col: pos.col + offset \n              });\n            }\n          });\n        }\n      }\n    }\n\n    // Filter out moves that would put or leave the king in check\n    if (!isCheckTest) {\n      moves = moves.filter(move => {\n        const boardCopy = testBoard.map(row => row.map(square => ({ ...square })));\n        boardCopy[move.row][move.col].piece = boardCopy[pos.row][pos.col].piece;\n        boardCopy[pos.row][pos.col].piece = null;\n        return !isKingInCheck(piece.color, boardCopy);\n      });\n    }\n\n    return moves;\n  }\n\n  return (\n    <div className=\"chess-board\" ref={boardRef}>\n      {board.map((row, i) => (\n        <div key={i} className=\"board-row\">\n          {row.map((square, j) => {\n            const isLastMoveFrom = lastMove?.from.row === i && lastMove?.from.col === j;\n            const isLastMoveTo = lastMove?.to.row === i && lastMove?.to.col === j;\n            const isCheck = square.piece?.type === 'king' && \n                          square.piece.color === currentPlayer && \n                          gameStatus === 'check';\n\n            return (\n            <div\n              key={`${i}-${j}`}\n              className={`square ${square.color} ${\n                selectedPiece?.row === i && selectedPiece?.col === j ? 'selected' : ''\n              } ${\n                validMoves.some(move => move.row === i && move.col === j) ? 'valid-move' : ''\n                } ${\n                  isLastMoveFrom || isLastMoveTo ? 'last-move' : ''\n                } ${\n                  isCheck ? 'check' : ''\n              }`}\n              data-position={`${i}-${j}`}\n                data-file={i === 7 ? FILES[j] : ''}\n                data-rank={j === 0 ? RANKS[i] : ''}\n              onClick={() => handleSquareClick(i, j)}\n            >\n                {square.piece && (\n                  <div className={`piece ${isLastMoveTo ? 'piece-moving' : ''}`}>\n                    {PIECE_SYMBOLS[square.piece.type][square.piece.color]}\n            </div>\n                )}\n              </div>\n            );\n          })}\n        </div>\n      ))}\n      {promotionState && (\n        <PromotionDialog\n          color={board[promotionState.position.row][promotionState.position.col].piece!.color}\n          position={promotionState.dialogPosition}\n          onSelect={handlePromotion}\n        />\n      )}\n\n      {gameStatus === 'checkmate' && (\n        <CheckmatePopup\n          winner={currentPlayer === 'white' ? 'black' : 'white'}\n          onNewGame={onNewGame}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default ChessBoard; ","import React from 'react';\nimport './MoveHistory.css';\n\ninterface Move {\n  piece: string;\n  from: string;\n  to: string;\n  capture?: boolean;\n  check?: boolean;\n  checkmate?: boolean;\n}\n\ninterface MoveHistoryProps {\n  moves: Move[];\n}\n\nconst MoveHistory: React.FC<MoveHistoryProps> = ({ moves }) => {\n  const formatMove = (move: Move): string => {\n    let notation = move.piece;\n    if (move.capture) notation += 'x';\n    notation += move.to;\n    if (move.checkmate) notation += '#';\n    else if (move.check) notation += '+';\n    return notation;\n  };\n\n  return (\n    <>\n      <h3 className=\"history-title\">Move History</h3>\n      <div className=\"moves-container\">\n        {moves.length === 0 ? (\n          <div className=\"no-moves\">No moves yet</div>\n        ) : (\n          <div className=\"moves-list\">\n            {moves.map((move, index) => (\n              <div key={index} className=\"move-entry\">\n                <span className=\"move-number\">{Math.floor(index / 2) + 1}.</span>\n                <span className={`move-text ${index % 2 === 0 ? 'white' : 'black'}`}>\n                  {formatMove(move)}\n                </span>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </>\n  );\n};\n\nexport default MoveHistory; ","import React from 'react';\nimport './GameModeSelector.css';\n\nexport type GameMode = 'computer' | 'player' | null;\n\ninterface GameModeSelectorProps {\n  onSelectMode: (mode: GameMode) => void;\n  username: string;\n}\n\nconst GameModeSelector: React.FC<GameModeSelectorProps> = ({ onSelectMode, username }) => {\n  return (\n    <div className=\"game-mode-selector\">\n      <h2>Welcome, {username}!</h2>\n      <p>Choose your game mode:</p>\n      <div className=\"mode-buttons\">\n        <button \n          className=\"mode-button computer\"\n          onClick={() => onSelectMode('computer')}\n        >\n          <span className=\"icon\">🤖</span>\n          <span className=\"label\">Play vs Computer</span>\n        </button>\n        <button \n          className=\"mode-button player\"\n          onClick={() => onSelectMode('player')}\n        >\n          <span className=\"icon\">👥</span>\n          <span className=\"label\">Play vs Player</span>\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default GameModeSelector; ","import React from 'react';\nimport { Piece } from './ComputerPlayer';\nimport './CapturedPieces.css';\n\ninterface CapturedPiecesProps {\n  pieces: Piece[];\n  color: 'white' | 'black';\n}\n\nconst CapturedPieces: React.FC<CapturedPiecesProps> = ({ pieces, color }) => {\n  const getPieceSymbol = (piece: Piece): string => {\n    const symbols = {\n      king: { white: '♔', black: '♚' },\n      queen: { white: '♕', black: '♛' },\n      rook: { white: '♖', black: '♜' },\n      bishop: { white: '♗', black: '♝' },\n      knight: { white: '♘', black: '♞' },\n      pawn: { white: '♙', black: '♟' }\n    };\n    return symbols[piece.type][piece.color];\n  };\n\n  // Sort pieces by value\n  const pieceValues = {\n    queen: 9,\n    rook: 5,\n    bishop: 3,\n    knight: 3,\n    pawn: 1,\n    king: 0\n  };\n\n  const sortedPieces = [...pieces].sort((a, b) => pieceValues[b.type] - pieceValues[a.type]);\n\n  return (\n    <div className={`captured-pieces ${color}`}>\n      <div className=\"captured-pieces-label\">{color === 'white' ? 'White' : 'Black'} captures:</div>\n      <div className=\"captured-pieces-list\">\n        {sortedPieces.map((piece, index) => (\n          <span key={index} className=\"captured-piece\">\n            {getPieceSymbol(piece)}\n          </span>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default CapturedPieces; ","import { PieceColor } from './Chess';\n\nexport interface Position {\n  row: number;\n  col: number;\n}\n\nexport interface Piece {\n  type: 'king' | 'queen' | 'rook' | 'bishop' | 'knight' | 'pawn';\n  color: PieceColor;\n}\n\nexport interface Square {\n  piece: Piece | null;\n  color: PieceColor;\n}\n\nconst PIECE_VALUES = {\n  pawn: 1,\n  knight: 3,\n  bishop: 3,\n  rook: 5,\n  queen: 9,\n  king: 100\n};\n\n// Position evaluation tables for improved piece positioning\nconst POSITION_VALUES = {\n  pawn: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 5, 5, 5, 5, 5, 5, 5],\n    [1, 1, 2, 3, 3, 2, 1, 1],\n    [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5],\n    [0, 0, 0, 2, 2, 0, 0, 0],\n    [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5],\n    [0.5, 1, 1, -2, -2, 1, 1, 0.5],\n    [0, 0, 0, 0, 0, 0, 0, 0]\n  ],\n  knight: [\n    [-5, -4, -3, -3, -3, -3, -4, -5],\n    [-4, -2, 0, 0, 0, 0, -2, -4],\n    [-3, 0, 1, 1.5, 1.5, 1, 0, -3],\n    [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3],\n    [-3, 0, 1.5, 2, 2, 1.5, 0, -3],\n    [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3],\n    [-4, -2, 0, 0.5, 0.5, 0, -2, -4],\n    [-5, -4, -3, -3, -3, -3, -4, -5]\n  ],\n  bishop: [\n    [-2, -1, -1, -1, -1, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 1, 1, 0.5, 0, -1],\n    [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1],\n    [-1, 0, 1, 1, 1, 1, 0, -1],\n    [-1, 1, 1, 1, 1, 1, 1, -1],\n    [-1, 0.5, 0, 0, 0, 0, 0.5, -1],\n    [-2, -1, -1, -1, -1, -1, -1, -2]\n  ],\n  rook: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 1, 1, 1, 1, 1, 1, 0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [0, 0, 0, 0.5, 0.5, 0, 0, 0]\n  ],\n  queen: [\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-1, 0, 0.5, 0, 0, 0, 0, -1],\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2]\n  ],\n  king: [\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-2, -3, -3, -4, -4, -3, -3, -2],\n    [-1, -2, -2, -2, -2, -2, -2, -1],\n    [2, 2, 0, 0, 0, 0, 2, 2],\n    [2, 3, 1, 0, 0, 1, 3, 2]\n  ]\n};\n\nexport class ComputerPlayer {\n  private getValidMoves(pos: Position, piece: Piece, board: Square[][]): Position[] {\n    const moves: Position[] = [];\n    const directions: { [key: string]: [number, number][] } = {\n      pawn: piece.color === 'white' ? [[-1, 0]] : [[1, 0]],\n      knight: [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]],\n      bishop: [[-1, -1], [-1, 1], [1, -1], [1, 1]],\n      rook: [[-1, 0], [1, 0], [0, -1], [0, 1]],\n      queen: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]],\n      king: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    };\n\n    const isSlidingPiece = ['bishop', 'rook', 'queen'].includes(piece.type);\n\n    // Special pawn moves\n    if (piece.type === 'pawn') {\n      const direction = piece.color === 'white' ? -1 : 1;\n      const startRow = piece.color === 'white' ? 6 : 1;\n\n      // Forward move\n      if (this.isValidPosition(pos.row + direction, pos.col) && \n          !board[pos.row + direction][pos.col].piece) {\n        moves.push({ row: pos.row + direction, col: pos.col });\n\n        // Initial two-square move\n        if (pos.row === startRow && !board[pos.row + direction * 2][pos.col].piece) {\n          moves.push({ row: pos.row + direction * 2, col: pos.col });\n        }\n      }\n\n      // Captures\n      [-1, 1].forEach(offset => {\n        const newRow = pos.row + direction;\n        const newCol = pos.col + offset;\n        if (this.isValidPosition(newRow, newCol)) {\n          const targetPiece = board[newRow][newCol].piece;\n          if (targetPiece && targetPiece.color !== piece.color) {\n            moves.push({ row: newRow, col: newCol });\n          }\n        }\n      });\n\n      return moves;\n    }\n\n    // Handle other pieces\n    directions[piece.type].forEach(([rowDir, colDir]) => {\n      let newRow = pos.row + rowDir;\n      let newCol = pos.col + colDir;\n\n      while (this.isValidPosition(newRow, newCol)) {\n        const targetSquare = board[newRow][newCol];\n        if (!targetSquare.piece) {\n          moves.push({ row: newRow, col: newCol });\n        } else {\n          if (targetSquare.piece.color !== piece.color) {\n            moves.push({ row: newRow, col: newCol });\n          }\n          break;\n        }\n\n        if (!isSlidingPiece) break;\n        newRow += rowDir;\n        newCol += colDir;\n      }\n    });\n\n    return moves;\n  }\n\n  private isValidPosition(row: number, col: number): boolean {\n    return row >= 0 && row < 8 && col >= 0 && col < 8;\n  }\n\n  private evaluatePosition(board: Square[][]): number {\n    let score = 0;\n\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        const piece = board[row][col].piece;\n        if (piece) {\n          const baseValue = PIECE_VALUES[piece.type];\n          const positionValue = POSITION_VALUES[piece.type][piece.color === 'white' ? row : 7 - row][col];\n          const value = baseValue + positionValue;\n          score += piece.color === 'black' ? value : -value;\n        }\n      }\n    }\n\n    return score;\n  }\n\n  private minimax(\n    board: Square[][],\n    depth: number,\n    alpha: number,\n    beta: number,\n    isMaximizing: boolean\n  ): { score: number; move?: { from: Position; to: Position } } {\n    if (depth === 0) {\n      return { score: this.evaluatePosition(board) };\n    }\n\n    const moves: { from: Position; to: Position }[] = [];\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        const piece = board[row][col].piece;\n        if (piece && piece.color === (isMaximizing ? 'black' : 'white')) {\n          const validMoves = this.getValidMoves({ row, col }, piece, board);\n          validMoves.forEach(to => {\n            moves.push({ from: { row, col }, to });\n          });\n        }\n      }\n    }\n\n    if (isMaximizing) {\n      let maxScore = -Infinity;\n      let bestMove;\n\n      for (const move of moves) {\n        const newBoard = this.makeMove(board, move);\n        const evaluation = this.minimax(newBoard, depth - 1, alpha, beta, false);\n        \n        if (evaluation.score > maxScore) {\n          maxScore = evaluation.score;\n          bestMove = move;\n        }\n        alpha = Math.max(alpha, evaluation.score);\n        if (beta <= alpha) break;\n      }\n\n      return { score: maxScore, move: bestMove };\n    } else {\n      let minScore = Infinity;\n      let bestMove;\n\n      for (const move of moves) {\n        const newBoard = this.makeMove(board, move);\n        const evaluation = this.minimax(newBoard, depth - 1, alpha, beta, true);\n        \n        if (evaluation.score < minScore) {\n          minScore = evaluation.score;\n          bestMove = move;\n        }\n        beta = Math.min(beta, evaluation.score);\n        if (beta <= alpha) break;\n      }\n\n      return { score: minScore, move: bestMove };\n    }\n  }\n\n  private makeMove(board: Square[][], move: { from: Position; to: Position }): Square[][] {\n    const newBoard = board.map(row => row.map(square => ({ ...square })));\n    newBoard[move.to.row][move.to.col].piece = newBoard[move.from.row][move.from.col].piece;\n    newBoard[move.from.row][move.from.col].piece = null;\n    return newBoard;\n  }\n\n  getBestMove(board: Square[][]): { from: Position; to: Position } | null {\n    const result = this.minimax(board, 3, -Infinity, Infinity, true);\n    return result.move || null;\n  }\n} ","import React, { useState, useEffect, useCallback } from 'react';\nimport ChessBoard from './ChessBoard';\nimport MoveHistory from './MoveHistory';\nimport GameModeSelector, { GameMode } from './GameModeSelector';\nimport CapturedPieces from './CapturedPieces';\nimport { ComputerPlayer, Square, Piece } from './ComputerPlayer';\nimport './Chess.css';\n\nexport type PieceColor = 'white' | 'black';\nexport type GameStatus = 'active' | 'check' | 'checkmate';\n\ninterface Move {\n  piece: string;\n  from: string;\n  to: string;\n  capture?: boolean;\n  check?: boolean;\n  checkmate?: boolean;\n}\n\ninterface BoardState {\n  board: Square[][];\n  currentPlayer: PieceColor;\n  gameStatus: GameStatus;\n  move: Move;\n}\n\ninterface ChessProps {\n  username: string;\n}\n\nconst Chess: React.FC<ChessProps> = ({ username }) => {\n  const [currentPlayer, setCurrentPlayer] = useState<PieceColor>('white');\n  const [gameStatus, setGameStatus] = useState<GameStatus>('active');\n  const [moveHistory, setMoveHistory] = useState<Move[]>([]);\n  const [boardHistory, setBoardHistory] = useState<BoardState[]>([]);\n  const [canUndo, setCanUndo] = useState(false);\n  const [gameMode, setGameMode] = useState<GameMode>(null);\n  const [computerPlayer] = useState(() => new ComputerPlayer());\n  const [capturedPieces, setCapturedPieces] = useState<{ white: Piece[], black: Piece[] }>({\n    white: [],\n    black: []\n  });\n\n  const getInitialPiece = (row: number, col: number): Piece | null => {\n    if (row <= 1) {\n      const color: PieceColor = 'black';\n      if (row === 1) return { type: 'pawn', color };\n      const pieceMap: Piece['type'][] = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];\n      return { type: pieceMap[col], color };\n    } else if (row >= 6) {\n      const color: PieceColor = 'white';\n      if (row === 6) return { type: 'pawn', color };\n      const pieceMap: Piece['type'][] = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];\n      return { type: pieceMap[col], color };\n    }\n    return null;\n  };\n\n  const getSquareNotation = (row: number, col: number): string => {\n    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n    return `${files[col]}${8 - row}`;\n  };\n\n  const makeMove = (board: Square[][], move: { from: { row: number; col: number }; to: { row: number; col: number } }): Square[][] => {\n    const newBoard = board.map(row => row.map(square => ({ ...square })));\n    newBoard[move.to.row][move.to.col].piece = newBoard[move.from.row][move.from.col].piece;\n    newBoard[move.from.row][move.from.col].piece = null;\n    return newBoard;\n  };\n\n  const handleMove = useCallback((move: Move, boardState: Square[][]) => {\n    setMoveHistory(prevMoves => [...prevMoves, move]);\n    setCurrentPlayer(prevPlayer => prevPlayer === 'white' ? 'black' : 'white');\n    \n    const newStatus = move.checkmate ? 'checkmate' : (move.check ? 'check' : 'active');\n    setGameStatus(newStatus);\n\n    // Check for captured pieces\n    if (move.capture) {\n      const lastState = boardHistory[boardHistory.length - 1];\n      if (lastState) {\n        const toCoords = parseSquareNotation(move.to);\n        const capturedPiece = lastState.board[toCoords.row][toCoords.col].piece;\n        if (capturedPiece) {\n          const capturingColor = currentPlayer === 'white' ? 'white' : 'black';\n          setCapturedPieces(prev => ({\n            ...prev,\n            [capturingColor]: [...prev[capturingColor], capturedPiece]\n          }));\n        }\n      }\n    }\n\n    setBoardHistory(prevHistory => [...prevHistory, {\n      board: boardState,\n      currentPlayer,\n      gameStatus: newStatus,\n      move\n    }]);\n    setCanUndo(true);\n  }, [boardHistory, currentPlayer]);\n\n  // This effect handles the computer's move in computer mode\n  useEffect(() => {\n    const initializeBoard = (): Square[][] => {\n      const board: Square[][] = [];\n      for (let i = 0; i < 8; i++) {\n        const row: Square[] = [];\n        for (let j = 0; j < 8; j++) {\n          row.push({\n            piece: getInitialPiece(i, j),\n            color: (i + j) % 2 === 0 ? 'white' : 'black'\n          });\n        }\n        board.push(row);\n      }\n      return board;\n    };\n\n    if (gameMode === 'computer' && currentPlayer === 'black') {\n      const timeoutId = setTimeout(() => {\n        const lastState = boardHistory[boardHistory.length - 1];\n        if (lastState) {\n          const computerMove = computerPlayer.getBestMove(lastState.board);\n          if (computerMove) {\n            const from = getSquareNotation(computerMove.from.row, computerMove.from.col);\n            const to = getSquareNotation(computerMove.to.row, computerMove.to.col);\n            handleMove({\n              piece: lastState.board[computerMove.from.row][computerMove.from.col].piece?.type || '',\n              from,\n              to\n            }, makeMove(lastState ? lastState.board : initializeBoard(), computerMove));\n          }\n        }\n      }, 500);\n\n      return () => clearTimeout(timeoutId);\n    }\n  }, [currentPlayer, gameMode, boardHistory, computerPlayer, handleMove]);\n\n  const parseSquareNotation = (notation: string): { row: number; col: number } => {\n    const file = notation.charAt(0).toLowerCase();\n    const rank = parseInt(notation.charAt(1));\n    const col = file.charCodeAt(0) - 'a'.charCodeAt(0);\n    const row = 8 - rank;\n    return { row, col };\n  };\n\n  const handleUndo = () => {\n    if (boardHistory.length === 0) return;\n\n    // In computer mode, undo both player's and computer's moves\n    if (gameMode === 'computer') {\n      const newMoveHistory = [...moveHistory];\n      newMoveHistory.pop();\n      newMoveHistory.pop();\n      setMoveHistory(newMoveHistory);\n\n      const newBoardHistory = [...boardHistory];\n      newBoardHistory.pop();\n      newBoardHistory.pop();\n      setBoardHistory(newBoardHistory);\n\n      const previousState = newBoardHistory[newBoardHistory.length - 1];\n      if (previousState) {\n        setCurrentPlayer(previousState.currentPlayer);\n        setGameStatus(previousState.gameStatus);\n      } else {\n        setCurrentPlayer('white');\n        setGameStatus('active');\n      }\n\n      setCanUndo(newBoardHistory.length > 0);\n    } else {\n      // In player vs player mode, undo one move at a time\n      const newMoveHistory = [...moveHistory];\n      newMoveHistory.pop();\n      setMoveHistory(newMoveHistory);\n\n      const newBoardHistory = [...boardHistory];\n      const previousState = newBoardHistory.pop();\n      setBoardHistory(newBoardHistory);\n\n      if (previousState) {\n        setCurrentPlayer(previousState.currentPlayer);\n        setGameStatus(previousState.gameStatus);\n      }\n\n      setCanUndo(newBoardHistory.length > 0);\n    }\n  };\n\n  const handleNewGame = () => {\n    setCurrentPlayer('white');\n    setGameStatus('active');\n    setMoveHistory([]);\n    setBoardHistory([]);\n    setCanUndo(false);\n    setCapturedPieces({ white: [], black: [] });\n  };\n\n  if (!gameMode) {\n    return <GameModeSelector username={username} onSelectMode={setGameMode} />;\n  }\n\n  return (\n    <div className=\"chess-game\">\n      <div className=\"game-info\">\n        <div className=\"current-player\">\n          Current Player: {currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}\n        </div>\n        <div className=\"game-controls\">\n          <button \n            className=\"control-button undo-button\" \n            onClick={handleUndo}\n            disabled={!canUndo}\n            title=\"Undo last move\"\n          >\n            ↩ Undo\n          </button>\n          <button \n            className=\"control-button new-game-button\" \n            onClick={handleNewGame}\n            title=\"Start a new game\"\n          >\n            New Game\n          </button>\n          <button\n            className=\"control-button mode-button\"\n            onClick={() => setGameMode(null)}\n            title=\"Change game mode\"\n          >\n            Change Mode\n          </button>\n        </div>\n        <div className=\"game-status\">\n          Status: {gameStatus.charAt(0).toUpperCase() + gameStatus.slice(1)}\n        </div>\n        <div className=\"game-mode\">\n          Mode: {gameMode === 'computer' ? 'vs Computer' : 'vs Player'}\n        </div>\n      </div>\n      <div className=\"game-container\">\n        <div className=\"game-board\">\n          <CapturedPieces pieces={capturedPieces.black} color=\"black\" />\n          <ChessBoard\n            currentPlayer={currentPlayer}\n            gameStatus={gameStatus}\n            onMove={handleMove}\n            onNewGame={handleNewGame}\n            boardHistory={boardHistory}\n          />\n          <CapturedPieces pieces={capturedPieces.white} color=\"white\" />\n        </div>\n        <div className=\"move-history\">\n          <MoveHistory moves={moveHistory} />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Chess; ","import React, { useEffect, useState } from 'react';\nimport Chess from './Chess/Chess';\n\n// Import the PiNetwork interface from typedefs\nimport { PiNetwork } from './typedefs';\n\n// Extend Window interface to include Pi SDK\ndeclare global {\n  interface Window {\n    Pi?: PiNetwork;\n  }\n}\n\nconst PiWrapper: React.FC = () => {\n  const [username, setUsername] = useState<string>('');\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  const onIncompletePayment = (payment: any) => {\n    console.log('Incomplete payment found:', payment);\n    // Handle incomplete payment here\n  };\n\n  useEffect(() => {\n    // Initialize Pi SDK\n    if (window.Pi) {\n      window.Pi.init({ version: '2.0', sandbox: true }); // Set sandbox to false for production\n    }\n\n    const authenticate = async () => {\n      setIsLoading(true);\n      setError(null);\n      \n      try {\n        if (!window.Pi) {\n          throw new Error('Pi Network SDK not loaded. Please make sure you are accessing this app through the Pi Browser.');\n        }\n\n        const result = await window.Pi.authenticate(['username', 'payments'], { \n          onIncompletePaymentFound: onIncompletePayment \n        });\n        \n        setUsername(result.user.username);\n        setIsAuthenticated(true);\n      } catch (err: any) {\n        console.error('Authentication failed:', err);\n        setError(err.message || 'Failed to authenticate with Pi Network');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    // Add a small delay to ensure Pi SDK is fully loaded\n    const timer = setTimeout(() => {\n      authenticate();\n    }, 1000);\n\n    return () => clearTimeout(timer);\n  }, []);\n\n  if (isLoading) {\n    return <div>Connecting to Pi Network...</div>;\n  }\n\n  if (error) {\n    return (\n      <div>\n        <h2>Error</h2>\n        <p>{error}</p>\n        <p>Please make sure you are:</p>\n        <ul>\n          <li>Using the Pi Browser</li>\n          <li>Your app is properly configured in the Pi Developer Portal</li>\n          <li>You have a stable internet connection</li>\n        </ul>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      {isAuthenticated ? (\n        <Chess username={username} />\n      ) : (\n        <div>\n          <h2>Welcome to Pi Chess</h2>\n          <p>Please wait while we connect to Pi Network...</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default PiWrapper;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'normalize.css';\nimport './defaults.css';\nimport PiWrapper from './PiWrapper';\n\n// Set Pi Network sandbox mode for development\nif (window.Pi) {\n  window.Pi.init({ version: '2.0', sandbox: true }); // Set sandbox to false for production\n}\n\nReactDOM.render(\n  <React.StrictMode>\n    <PiWrapper />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}